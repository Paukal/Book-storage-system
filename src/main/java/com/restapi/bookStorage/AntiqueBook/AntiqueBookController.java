/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.restapi.bookStorage.AntiqueBook;

/**
 *
 * @author Paul
 */
import com.restapi.bookStorage.Test;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.Year;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import org.springframework.web.bind.annotation.ResponseBody;

@RestController
@RequestMapping(path = "/antiquebook")
public class AntiqueBookController {

    @Autowired // This means to get the bean called bookRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AntiqueBookRepository antiqueBookRepository;

    @PostMapping(path = "/add") // Map ONLY POST Requests
    public @ResponseBody
    String addNewAntiqueBook(@RequestParam String name,
            @RequestParam String author, @RequestParam int barcode,
            @RequestParam int quantity, @RequestParam int price, @RequestParam int rel_year) {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        Optional<AntiqueBook> books = antiqueBookRepository.findById(barcode);
        if (books.isEmpty()) {
            if (rel_year <= 1900) {
                AntiqueBook n = new AntiqueBook(name, author, barcode, quantity, price, rel_year);

                /*
                LOGGING TO FILE:
                */
                try (FileWriter fw = new FileWriter("AntiqueBookLog.txt", true);
                        BufferedWriter bw = new BufferedWriter(fw);
                        PrintWriter out = new PrintWriter(bw)) {
                    out.println("Added new antique book: Name=" + n.getName() + "," + "Author=" + n.getAuthor() + "," + "Barcode=" + n.getBarcode()
                            + "," + "Quantity=" + n.getQuantity() + "," + "Price=" + n.getPrice() + "," + "Release year=" + n.getYear());
                } catch (IOException ex) {
                    Logger.getLogger(AntiqueBookController.class.getName()).log(Level.SEVERE, null, ex);
                };

                antiqueBookRepository.save(n);
                return "Saved";
            } else {
                return "Book's release date must be no more recent than 1900. Try adding to regular book table.";
            }
        }
        else
            return "Book already exists. If you want to change the quantity or any other fields, go to UPDATE BOOK INFO.";
    }

    //GET book providing barcode
    @GetMapping("/get")
    public Optional<AntiqueBook> getAntiqueBook(@RequestParam(value = "barcode") int barcode) {
        return antiqueBookRepository.findById(barcode);
    }

    @PostMapping(path = "/update") // Map ONLY POST Requests
    public @ResponseBody
    String updateAntiqueBook(@RequestParam String name,
            @RequestParam String author, @RequestParam int barcode,
            @RequestParam int quantity, @RequestParam int price, @RequestParam int rel_year) {

        //get book by barcode
        //set all fields which will be passed to book constructor
        //delete book by barcode
        //create new book with changed fields
        Optional<AntiqueBook> oldBook = antiqueBookRepository.findById(barcode);
        if (!oldBook.isEmpty()) {
            String oldName = oldBook.get().getName();
            String oldAuthor = oldBook.get().getAuthor();
            int oldQuantity = oldBook.get().getQuantity();
            int oldPrice = oldBook.get().getPrice();
            int oldRel_year = oldBook.get().getYear();

            if (name != null) {
                oldName = name;
            }
            if (author != null) {
                oldAuthor = author;
            }
            if (quantity != -1) {
                oldQuantity = quantity;
            }
            if (price != -1) {
                oldPrice = price;
            }
            if (rel_year != -1) {
                oldRel_year = rel_year;
            }

            //antiqueBookRepository.deleteById(barcode);

            AntiqueBook n = new AntiqueBook(oldName, oldAuthor, barcode, oldQuantity, oldPrice, oldRel_year);

            antiqueBookRepository.save(n);
            return "Saved";
        } else {
            return "Book with entered barcode doesn't exist";
        }
    }

    //calculation of book price
    @GetMapping("/calculate")
    public @ResponseBody
    String calculateBookPrice(@RequestParam(value = "barcode") int barcode) {
        Optional<AntiqueBook> antiqueBooks = antiqueBookRepository.findById(barcode);
        if (!antiqueBooks.isEmpty()) {
            int currentYear = Year.now().getValue();
            int price = antiqueBooks.get().getPrice() * antiqueBooks.get().getQuantity()
                    * (currentYear - antiqueBooks.get().getYear()) / 10;
            return "Total price of selected books=" + price;
        } else {
            return "This book doesn't exist";
        }
    }

    //for server and REST test purposes
    private static final String template = "Hello, %s!";
    private final AtomicLong counter = new AtomicLong();

    @GetMapping("/test")
    public Test greeting(@RequestParam(value = "name", defaultValue = "World") String name) {
        return new Test(counter.incrementAndGet(), String.format(template, name));
    }

}
